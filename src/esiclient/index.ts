/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 0.3.9
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');

let defaultBasePath = 'https://esi.tech.ccp.is/latest';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* target object
*/
export class CharacterscharacterIdbookmarksTarget {
    'coordinates': CharacterscharacterIdbookmarksTargetCoordinates;
    'item': CharacterscharacterIdbookmarksTargetItem;
    /**
    * location_id integer
    */
    'locationId': number;
}

/**
* coordinates object
*/
export class CharacterscharacterIdbookmarksTargetCoordinates {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* item object
*/
export class CharacterscharacterIdbookmarksTargetItem {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* item object
*/
export class CharacterscharacterIdfittingsItems {
    /**
    * flag integer
    */
    'flag': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* item object
*/
export class CharacterscharacterIdfittingsItems1 {
    /**
    * flag integer
    */
    'flag': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* recipient object
*/
export class CharacterscharacterIdmailRecipients {
    /**
    * recipient_id integer
    */
    'recipientId': number;
    /**
    * recipient_type string
    */
    'recipientType': CharacterscharacterIdmailRecipients.RecipientTypeEnum;
}

export namespace CharacterscharacterIdmailRecipients {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* recipient object
*/
export class CharacterscharacterIdmailRecipients1 {
    /**
    * recipient_id integer
    */
    'recipientId': number;
    /**
    * recipient_type string
    */
    'recipientType': CharacterscharacterIdmailRecipients1.RecipientTypeEnum;
}

export namespace CharacterscharacterIdmailRecipients1 {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* alliance object
*/
export class CorporationscorporationIdalliancehistoryAlliance {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * True if the alliance has been deleted
    */
    'isDeleted': boolean;
}

/**
* Forbidden
*/
export class DeleteCharactersCharacterIdContactsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteCharactersCharacterIdContactsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class DeleteCharactersCharacterIdFittingsFittingIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteCharactersCharacterIdFittingsFittingIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class DeleteCharactersCharacterIdMailLabelsLabelIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteCharactersCharacterIdMailLabelsLabelIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Unprocessable entity
*/
export class DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* Forbidden
*/
export class DeleteCharactersCharacterIdMailMailIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteCharactersCharacterIdMailMailIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class DeleteFleetsFleetIdMembersMemberIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteFleetsFleetIdMembersMemberIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class DeleteFleetsFleetIdMembersMemberIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class DeleteFleetsFleetIdSquadsSquadIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteFleetsFleetIdSquadsSquadIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class DeleteFleetsFleetIdSquadsSquadIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class DeleteFleetsFleetIdWingsWingIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class DeleteFleetsFleetIdWingsWingIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class DeleteFleetsFleetIdWingsWingIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* squad object
*/
export class FleetsfleetIdwingsSquads {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* Internal server error
*/
export class GetAlliancesAllianceIdCorporationsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetAlliancesAllianceIdIconsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* No image server for this datasource
*/
export class GetAlliancesAllianceIdIconsNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdIconsOk {
    /**
    * px128x128 string
    */
    'px128x128': string;
    /**
    * px64x64 string
    */
    'px64x64': string;
}

/**
* Internal server error
*/
export class GetAlliancesAllianceIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Alliance not found
*/
export class GetAlliancesAllianceIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdOk {
    /**
    * the full name of the alliance
    */
    'allianceName': string;
    /**
    * date_founded string
    */
    'dateFounded': Date;
    /**
    * the executor corporation ID, if this alliance is not closed
    */
    'executorCorp': number;
    /**
    * the short name of the alliance
    */
    'ticker': string;
}

/**
* Internal server error
*/
export class GetAlliancesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetAlliancesNames200Ok {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * alliance_name string
    */
    'allianceName': string;
}

/**
* Internal server error
*/
export class GetAlliancesNamesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdAssets200Ok {
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCharactersCharacterIdAssets200Ok.LocationFlagEnum;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdAssets200Ok.LocationTypeEnum;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

export namespace GetCharactersCharacterIdAssets200Ok {
    export enum LocationFlagEnum {
        AutoFit = <any> 'AutoFit',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        DroneBay = <any> 'DroneBay',
        FleetHangar = <any> 'FleetHangar',
        Deliveries = <any> 'Deliveries',
        HiddenModifiers = <any> 'HiddenModifiers',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        AssetSafety = <any> 'AssetSafety',
        Locked = <any> 'Locked',
        Unlocked = <any> 'Unlocked',
        Implant = <any> 'Implant',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        Module = <any> 'Module'
    }
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Other = <any> 'other'
    }
}
/**
* Forbidden
*/
export class GetCharactersCharacterIdAssetsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdAssetsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdBookmarks200Ok {
    /**
    * bookmark_id integer
    */
    'bookmarkId': number;
    /**
    * create_date string
    */
    'createDate': Date;
    /**
    * creator_id integer
    */
    'creatorId': number;
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * memo string
    */
    'memo': string;
    /**
    * note string
    */
    'note': string;
    /**
    * owner_id integer
    */
    'ownerId': number;
    'target': CharacterscharacterIdbookmarksTarget;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdBookmarksFolders200Ok {
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * owner_id integer
    */
    'ownerId': number;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdBookmarksFoldersForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdBookmarksFoldersInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdBookmarksForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdBookmarksInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* event
*/
export class GetCharactersCharacterIdCalendar200Ok {
    /**
    * event_date string
    */
    'eventDate': Date;
    /**
    * event_id integer
    */
    'eventId': number;
    /**
    * event_response string
    */
    'eventResponse': GetCharactersCharacterIdCalendar200Ok.EventResponseEnum;
    /**
    * importance integer
    */
    'importance': number;
    /**
    * title string
    */
    'title': string;
}

export namespace GetCharactersCharacterIdCalendar200Ok {
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}
/**
* Forbidden
*/
export class GetCharactersCharacterIdCalendarEventIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdCalendarEventIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Full details of a specific event
*/
export class GetCharactersCharacterIdCalendarEventIdOk {
    /**
    * date string
    */
    'date': Date;
    /**
    * Length in minutes
    */
    'duration': number;
    /**
    * event_id integer
    */
    'eventId': number;
    /**
    * importance integer
    */
    'importance': number;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * owner_name string
    */
    'ownerName': string;
    /**
    * owner_type string
    */
    'ownerType': GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum;
    /**
    * response string
    */
    'response': string;
    /**
    * text string
    */
    'text': string;
    /**
    * title string
    */
    'title': string;
}

export namespace GetCharactersCharacterIdCalendarEventIdOk {
    export enum OwnerTypeEnum {
        EveServer = <any> 'eve_server',
        Corporation = <any> 'corporation',
        Faction = <any> 'faction',
        Character = <any> 'character',
        Alliance = <any> 'alliance'
    }
}
/**
* Forbidden
*/
export class GetCharactersCharacterIdCalendarForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdCalendarInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdClonesForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdClonesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdClonesOk {
    'homeLocation': GetCharactersCharacterIdClonesOkHomeLocation;
    /**
    * jump_clones array
    */
    'jumpClones': Array<GetCharactersCharacterIdClonesOkJumpClones>;
    /**
    * last_jump_date string
    */
    'lastJumpDate': Date;
}

/**
* home_location object
*/
export class GetCharactersCharacterIdClonesOkHomeLocation {
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdClonesOkHomeLocation.LocationTypeEnum;
}

export namespace GetCharactersCharacterIdClonesOkHomeLocation {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}
/**
* jump_clone object
*/
export class GetCharactersCharacterIdClonesOkJumpClones {
    /**
    * implants array
    */
    'implants': Array<number>;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdClonesOkJumpClones.LocationTypeEnum;
}

export namespace GetCharactersCharacterIdClonesOkJumpClones {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdContacts200Ok {
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * contact_type string
    */
    'contactType': GetCharactersCharacterIdContacts200Ok.ContactTypeEnum;
    /**
    * Whether this contact is in the blocked list. Note a missing value denotes unknown, not true or false
    */
    'isBlocked': boolean;
    /**
    * Whether this contact is being watched
    */
    'isWatched': boolean;
    /**
    * Custom label of the contact
    */
    'labelId': number;
    /**
    * Standing of the contact
    */
    'standing': number;
}

export namespace GetCharactersCharacterIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* Forbidden
*/
export class GetCharactersCharacterIdContactsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdContactsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContactsLabels200Ok {
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * label_name string
    */
    'labelName': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdContactsLabelsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdContactsLabelsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdCorporationhistory200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * True if the corporation has been deleted
    */
    'isDeleted': boolean;
    /**
    * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
    */
    'recordId': number;
    /**
    * start_date string
    */
    'startDate': Date;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdCorporationhistoryInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFittings200Ok {
    /**
    * description string
    */
    'description': string;
    /**
    * fitting_id integer
    */
    'fittingId': number;
    /**
    * items array
    */
    'items': Array<CharacterscharacterIdfittingsItems>;
    /**
    * name string
    */
    'name': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdFittingsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdFittingsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdKillmailsRecent200Ok {
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
    /**
    * ID of this killmail
    */
    'killmailId': number;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdKillmailsRecentForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdKillmailsRecentInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdLocationForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdLocationInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdLocationOk {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * station_id integer
    */
    'stationId': number;
    /**
    * structure_id integer
    */
    'structureId': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMail200Ok {
    /**
    * From whom the mail was sent
    */
    'from': number;
    /**
    * is_read boolean
    */
    'isRead': boolean;
    /**
    * labels array
    */
    'labels': Array<number>;
    /**
    * mail_id integer
    */
    'mailId': number;
    /**
    * Recipients of the mail
    */
    'recipients': Array<CharacterscharacterIdmailRecipients>;
    /**
    * Mail subject
    */
    'subject': string;
    /**
    * When the mail was sent
    */
    'timestamp': Date;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdMailForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdMailInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdMailLabelsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdMailLabelsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailLabelsOk {
    /**
    * labels array
    */
    'labels': Array<GetCharactersCharacterIdMailLabelsOkLabels>;
    /**
    * total_unread_count integer
    */
    'totalUnreadCount': number;
}

/**
* label object
*/
export class GetCharactersCharacterIdMailLabelsOkLabels {
    /**
    * color string
    */
    'color': GetCharactersCharacterIdMailLabelsOkLabels.ColorEnum;
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * unread_count integer
    */
    'unreadCount': number;
}

export namespace GetCharactersCharacterIdMailLabelsOkLabels {
    export enum ColorEnum {
        Ffffff = <any> '#ffffff',
        Ffff01 = <any> '#ffff01',
        Ff6600 = <any> '#ff6600',
        Fe0000 = <any> '#fe0000',
        _9a0000 = <any> '#9a0000',
        _660066 = <any> '#660066',
        _0000fe = <any> '#0000fe',
        _0099ff = <any> '#0099ff',
        _01ffff = <any> '#01ffff',
        _00ff33 = <any> '#00ff33',
        _349800 = <any> '#349800',
        _006634 = <any> '#006634',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        E6e6e6 = <any> '#e6e6e6',
        Ffffcd = <any> '#ffffcd',
        _99ffff = <any> '#99ffff',
        Ccff9a = <any> '#ccff9a'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailLists200Ok {
    /**
    * Mailing list ID
    */
    'mailingListId': number;
    /**
    * name string
    */
    'name': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdMailListsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdMailListsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdMailMailIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdMailMailIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Not found
*/
export class GetCharactersCharacterIdMailMailIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailMailIdOk {
    /**
    * Mail's body
    */
    'body': string;
    /**
    * From whom the mail was sent
    */
    'from': number;
    /**
    * Labels attached to the mail
    */
    'labels': Array<number>;
    /**
    * Whether the mail is flagged as read
    */
    'read': boolean;
    /**
    * Recipients of the mail
    */
    'recipients': Array<GetCharactersCharacterIdMailMailIdOkRecipients>;
    /**
    * Mail subject
    */
    'subject': string;
    /**
    * When the mail was sent
    */
    'timestamp': Date;
}

/**
* recipient object
*/
export class GetCharactersCharacterIdMailMailIdOkRecipients {
    /**
    * recipient_id integer
    */
    'recipientId': number;
    /**
    * recipient_type string
    */
    'recipientType': GetCharactersCharacterIdMailMailIdOkRecipients.RecipientTypeEnum;
}

export namespace GetCharactersCharacterIdMailMailIdOkRecipients {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdOk {
    /**
    * ancestry_id integer
    */
    'ancestryId': number;
    /**
    * Creation date of the character
    */
    'birthday': Date;
    /**
    * bloodline_id integer
    */
    'bloodlineId': number;
    /**
    * The character's corporation ID
    */
    'corporationId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * gender string
    */
    'gender': GetCharactersCharacterIdOk.GenderEnum;
    /**
    * The name of the character
    */
    'name': string;
    /**
    * race_id integer
    */
    'raceId': number;
    /**
    * security_status number
    */
    'securityStatus': number;
}

export namespace GetCharactersCharacterIdOk {
    export enum GenderEnum {
        Female = <any> 'female',
        Male = <any> 'male'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdPlanets200Ok {
    /**
    * last_update string
    */
    'lastUpdate': Date;
    /**
    * num_pins integer
    */
    'numPins': number;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * planet_id integer
    */
    'planetId': number;
    /**
    * planet_type string
    */
    'planetType': GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * upgrade_level integer
    */
    'upgradeLevel': number;
}

export namespace GetCharactersCharacterIdPlanets200Ok {
    export enum PlanetTypeEnum {
        Temperate = <any> 'temperate',
        Barren = <any> 'barren',
        Oceanic = <any> 'oceanic',
        Ice = <any> 'ice',
        Gas = <any> 'gas',
        Lava = <any> 'lava',
        Storm = <any> 'storm',
        Plasma = <any> 'plasma'
    }
}
/**
* Forbidden
*/
export class GetCharactersCharacterIdPlanetsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdPlanetsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdPlanetsPlanetIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdPlanetsPlanetIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Colony not found
*/
export class GetCharactersCharacterIdPlanetsPlanetIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOk {
    /**
    * links array
    */
    'links': Array<GetCharactersCharacterIdPlanetsPlanetIdOkLinks>;
    /**
    * pins array
    */
    'pins': Array<GetCharactersCharacterIdPlanetsPlanetIdOkPins>;
    /**
    * routes array
    */
    'routes': Array<GetCharactersCharacterIdPlanetsPlanetIdOkRoutes>;
}

/**
* extractor_details object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkExtractorDetails {
    /**
    * in seconds
    */
    'cycleTime': number;
    /**
    * head_radius number
    */
    'headRadius': number;
    /**
    * heads array
    */
    'heads': Array<GetCharactersCharacterIdPlanetsPlanetIdOkExtractorDetailsHeads>;
    /**
    * product_type_id integer
    */
    'productTypeId': number;
    /**
    * qty_per_cycle integer
    */
    'qtyPerCycle': number;
}

/**
* head object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkExtractorDetailsHeads {
    /**
    * head_id integer
    */
    'headId': number;
    /**
    * latitude number
    */
    'latitude': number;
    /**
    * longitude number
    */
    'longitude': number;
}

/**
* factory_details object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkFactoryDetails {
    /**
    * schematic_id integer
    */
    'schematicId': number;
}

/**
* link object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkLinks {
    /**
    * destination_pin_id integer
    */
    'destinationPinId': number;
    /**
    * link_level integer
    */
    'linkLevel': number;
    /**
    * source_pin_id integer
    */
    'sourcePinId': number;
}

/**
* pin object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkPins {
    /**
    * expiry_time string
    */
    'expiryTime': Date;
    'extractorDetails': GetCharactersCharacterIdPlanetsPlanetIdOkExtractorDetails;
    'factoryDetails': GetCharactersCharacterIdPlanetsPlanetIdOkFactoryDetails;
    /**
    * install_time string
    */
    'installTime': Date;
    /**
    * last_cycle_start string
    */
    'lastCycleStart': Date;
    /**
    * latitude number
    */
    'latitude': number;
    /**
    * longitude number
    */
    'longitude': number;
    /**
    * pin_id integer
    */
    'pinId': number;
    /**
    * schematic_id integer
    */
    'schematicId': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* route object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkRoutes {
    /**
    * content_type_id integer
    */
    'contentTypeId': number;
    /**
    * destination_pin_id integer
    */
    'destinationPinId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * route_id integer
    */
    'routeId': number;
    /**
    * source_pin_id integer
    */
    'sourcePinId': number;
    /**
    * waypoints array
    */
    'waypoints': Array<GetCharactersCharacterIdPlanetsPlanetIdOkWaypoints>;
}

/**
* waypoint object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOkWaypoints {
    /**
    * order integer
    */
    'order': number;
    /**
    * pin_id integer
    */
    'pinId': number;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdPortraitInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* No image server for this datasource
*/
export class GetCharactersCharacterIdPortraitNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdPortraitOk {
    /**
    * px128x128 string
    */
    'px128x128': string;
    /**
    * px256x256 string
    */
    'px256x256': string;
    /**
    * px512x512 string
    */
    'px512x512': string;
    /**
    * px64x64 string
    */
    'px64x64': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdSearchForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdSearchInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSearchOk {
    /**
    * agent array
    */
    'agent': Array<number>;
    /**
    * alliance array
    */
    'alliance': Array<number>;
    /**
    * character array
    */
    'character': Array<number>;
    /**
    * constellation array
    */
    'constellation': Array<number>;
    /**
    * corporation array
    */
    'corporation': Array<number>;
    /**
    * faction array
    */
    'faction': Array<number>;
    /**
    * inventorytype array
    */
    'inventorytype': Array<number>;
    /**
    * region array
    */
    'region': Array<number>;
    /**
    * solarsystem array
    */
    'solarsystem': Array<number>;
    /**
    * station array
    */
    'station': Array<number>;
    /**
    * structure array
    */
    'structure': Array<number>;
    /**
    * wormhole array
    */
    'wormhole': Array<number>;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdShipForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdShipInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdShipOk {
    /**
    * Item id's are unique to a ship and persist until it is repackaged. This value can be used to track repeated uses of a ship, or detect when a pilot changes into a different instance of the same ship type.
    */
    'shipItemId': number;
    /**
    * ship_name string
    */
    'shipName': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSkillqueue200Ok {
    /**
    * finish_date string
    */
    'finishDate': Date;
    /**
    * finished_level integer
    */
    'finishedLevel': number;
    /**
    * level_end_sp integer
    */
    'levelEndSp': number;
    /**
    * Amount of SP that was in the skill when it started training it's current level. Used to calculate % of current level complete.
    */
    'levelStartSp': number;
    /**
    * queue_position integer
    */
    'queuePosition': number;
    /**
    * skill_id integer
    */
    'skillId': number;
    /**
    * start_date string
    */
    'startDate': Date;
    /**
    * training_start_sp integer
    */
    'trainingStartSp': number;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdSkillqueueForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdSkillqueueInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdSkillsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdSkillsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSkillsOk {
    /**
    * skills array
    */
    'skills': Array<GetCharactersCharacterIdSkillsOkSkills>;
    /**
    * total_sp integer
    */
    'totalSp': number;
}

/**
* skill object
*/
export class GetCharactersCharacterIdSkillsOkSkills {
    /**
    * current_skill_level integer
    */
    'currentSkillLevel': number;
    /**
    * skill_id integer
    */
    'skillId': number;
    /**
    * skillpoints_in_skill integer
    */
    'skillpointsInSkill': number;
}

/**
* Is not a character ID
*/
export class GetCharactersCharacterIdUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdWallets200Ok {
    /**
    * Wallet's balance in ISK hundredths.
    */
    'balance': number;
    /**
    * wallet_id integer
    */
    'walletId': number;
}

/**
* Forbidden
*/
export class GetCharactersCharacterIdWalletsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCharactersCharacterIdWalletsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersNames200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * character_name string
    */
    'characterName': string;
}

/**
* Internal server error
*/
export class GetCharactersNamesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdAlliancehistory200Ok {
    'alliance': CorporationscorporationIdalliancehistoryAlliance;
    /**
    * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
    */
    'recordId': number;
    /**
    * start_date string
    */
    'startDate': Date;
}

/**
* Internal server error
*/
export class GetCorporationsCorporationIdAlliancehistoryInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCorporationsCorporationIdIconsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* No image server for this datasource
*/
export class GetCorporationsCorporationIdIconsNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdIconsOk {
    /**
    * px128x128 string
    */
    'px128x128': string;
    /**
    * px256x256 string
    */
    'px256x256': string;
    /**
    * px64x64 string
    */
    'px64x64': string;
}

/**
* Internal server error
*/
export class GetCorporationsCorporationIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMembers200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
}

/**
* Forbidden
*/
export class GetCorporationsCorporationIdMembersForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCorporationsCorporationIdMembersInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Not found
*/
export class GetCorporationsCorporationIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOk {
    /**
    * id of alliance that corporation is a member of, if any
    */
    'allianceId': number;
    /**
    * ceo_id integer
    */
    'ceoId': number;
    /**
    * the full name of the corporation
    */
    'corporationName': string;
    /**
    * member_count integer
    */
    'memberCount': number;
    /**
    * the short name of the corporation
    */
    'ticker': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdRoles200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * grantable_roles array
    */
    'grantableRoles': GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum;
    /**
    * grantable_roles_at_base array
    */
    'grantableRolesAtBase': GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum;
    /**
    * grantable_roles_at_hq array
    */
    'grantableRolesAtHq': GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum;
    /**
    * grantable_roles_at_other array
    */
    'grantableRolesAtOther': GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum;
    /**
    * roles array
    */
    'roles': GetCorporationsCorporationIdRoles200Ok.RolesEnum;
    /**
    * roles_at_base array
    */
    'rolesAtBase': GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum;
    /**
    * roles_at_hq array
    */
    'rolesAtHq': GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum;
    /**
    * roles_at_other array
    */
    'rolesAtOther': GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum;
}

export namespace GetCorporationsCorporationIdRoles200Ok {
    export enum GrantableRolesEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum GrantableRolesAtBaseEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum GrantableRolesAtHqEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum GrantableRolesAtOtherEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum RolesEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum RolesAtBaseEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum RolesAtHqEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
    export enum RolesAtOtherEnum {
        Director = <any> 'Director',
        PersonnelManager = <any> 'Personnel_Manager',
        Accountant = <any> 'Accountant',
        SecurityOfficer = <any> 'Security_Officer',
        FactoryManager = <any> 'Factory_Manager',
        StationManager = <any> 'Station_Manager',
        Auditor = <any> 'Auditor',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Diplomat = <any> 'Diplomat',
        ConfigEquipment = <any> 'Config_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        RentOffice = <any> 'Rent_Office',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        JuniorAccountant = <any> 'Junior_Accountant',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        Trader = <any> 'Trader',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ContractManager = <any> 'Contract_Manager',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        FittingManager = <any> 'Fitting_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer'
    }
}
/**
* Forbidden
*/
export class GetCorporationsCorporationIdRolesForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetCorporationsCorporationIdRolesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsNames200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * corporation_name string
    */
    'corporationName': string;
}

/**
* Internal server error
*/
export class GetCorporationsNamesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetFleetsFleetIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetFleetsFleetIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdMembers200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * join_time string
    */
    'joinTime': Date;
    /**
    * Members role in fleet
    */
    'role': GetFleetsFleetIdMembers200Ok.RoleEnum;
    /**
    * Localized role names
    */
    'roleName': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * Solar system the member is located in
    */
    'solarSystemId': number;
    /**
    * ID of the squad the member is in. If not applicable, will be set to -1
    */
    'squadId': number;
    /**
    * Station in which the member is docked in, if applicable
    */
    'stationId': number;
    /**
    * Whether the member take fleet warps
    */
    'takesFleetWarp': boolean;
    /**
    * ID of the wing the member is in. If not applicable, will be set to -1
    */
    'wingId': number;
}

export namespace GetFleetsFleetIdMembers200Ok {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Forbidden
*/
export class GetFleetsFleetIdMembersForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetFleetsFleetIdMembersInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class GetFleetsFleetIdMembersNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class GetFleetsFleetIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdOk {
    /**
    * Is free-move enabled
    */
    'isFreeMove': boolean;
    /**
    * Does the fleet have an active fleet advertisement
    */
    'isRegistered': boolean;
    /**
    * Is EVE Voice enabled
    */
    'isVoiceEnabled': boolean;
    /**
    * Fleet MOTD in CCP flavoured HTML
    */
    'motd': string;
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdWings200Ok {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
    /**
    * squads array
    */
    'squads': Array<FleetsfleetIdwingsSquads>;
}

/**
* Forbidden
*/
export class GetFleetsFleetIdWingsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetFleetsFleetIdWingsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class GetFleetsFleetIdWingsNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetIncursions200Ok {
    /**
    * The constellation id in which this incursion takes place
    */
    'constellationId': number;
    /**
    * The attacking faction's id
    */
    'factionId': number;
    /**
    * Whether the final encounter has boss or not
    */
    'hasBoss': boolean;
    /**
    * A list of infested solar system ids that are a part of this incursion
    */
    'infestedSolarSystems': Array<number>;
    /**
    * Influence of this incursion as a float from 0 to 1
    */
    'influence': number;
    /**
    * Staging solar system for this incursion
    */
    'stagingSolarSystemId': number;
    /**
    * The state of this incursion
    */
    'state': GetIncursions200Ok.StateEnum;
    /**
    * The type of this incursion
    */
    'type': string;
}

export namespace GetIncursions200Ok {
    export enum StateEnum {
        Withdrawing = <any> 'withdrawing',
        Mobilizing = <any> 'mobilizing',
        Established = <any> 'established'
    }
}
/**
* Internal server error
*/
export class GetIncursionsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetIndustryFacilities200Ok {
    /**
    * ID of the facility
    */
    'facilityId': number;
    /**
    * Owner of the facility
    */
    'ownerId': number;
    /**
    * Region ID where the facility is
    */
    'regionId': number;
    /**
    * Solar system ID where the facility is
    */
    'solarSystemId': number;
    /**
    * Tax imposed by the facility
    */
    'tax': number;
    /**
    * Type ID of the facility
    */
    'typeId': number;
}

/**
* Internal server error
*/
export class GetIndustryFacilitiesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetIndustrySystems200Ok {
    /**
    * cost_indices array
    */
    'costIndices': Array<IndustrysystemsCostIndices>;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
}

/**
* Internal server error
*/
export class GetIndustrySystemsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetInsurancePrices200Ok {
    /**
    * A list of a available insurance levels for this ship type
    */
    'levels': Array<InsurancepricesLevels>;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* Internal server error
*/
export class GetInsurancePricesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetKillmailsKillmailIdKillmailHashInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetKillmailsKillmailIdKillmailHashOk {
    /**
    * attackers array
    */
    'attackers': Array<GetKillmailsKillmailIdKillmailHashOkAttackers>;
    /**
    * ID of the killmail
    */
    'killmailId': number;
    /**
    * Time that the victim was killed and the killmail generated 
    */
    'killmailTime': Date;
    /**
    * Moon if the kill took place at one
    */
    'moonId': number;
    /**
    * Solar system that the kill took place in 
    */
    'solarSystemId': number;
    'victim': GetKillmailsKillmailIdKillmailHashOkVictim;
    /**
    * War if the killmail is generated in relation to an official war 
    */
    'warId': number;
}

/**
* attacker object
*/
export class GetKillmailsKillmailIdKillmailHashOkAttackers {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * damage_done integer
    */
    'damageDone': number;
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Was the attacker the one to achieve the final blow 
    */
    'finalBlow': boolean;
    /**
    * Security status for the attacker 
    */
    'securityStatus': number;
    /**
    * What ship was the attacker flying 
    */
    'shipTypeId': number;
    /**
    * What weapon was used by the attacker for the kill 
    */
    'weaponTypeId': number;
}

/**
* victim object
*/
export class GetKillmailsKillmailIdKillmailHashOkVictim {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * How much total damage was taken by the victim 
    */
    'damageTaken': number;
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * items array
    */
    'items': Array<GetKillmailsKillmailIdKillmailHashOkVictimItems1>;
    'position': GetKillmailsKillmailIdKillmailHashOkVictimPosition;
    /**
    * The ship that the victim was piloting and was destroyed 
    */
    'shipTypeId': number;
}

/**
* item object
*/
export class GetKillmailsKillmailIdKillmailHashOkVictimItems {
    /**
    * flag integer
    */
    'flag': number;
    /**
    * item_type_id integer
    */
    'itemTypeId': number;
    /**
    * quantity_destroyed integer
    */
    'quantityDestroyed': number;
    /**
    * quantity_dropped integer
    */
    'quantityDropped': number;
    /**
    * singleton integer
    */
    'singleton': number;
}

/**
* item object
*/
export class GetKillmailsKillmailIdKillmailHashOkVictimItems1 {
    /**
    * Flag for the location of the item 
    */
    'flag': number;
    /**
    * item_type_id integer
    */
    'itemTypeId': number;
    /**
    * items array
    */
    'items': Array<GetKillmailsKillmailIdKillmailHashOkVictimItems>;
    /**
    * How many of the item were destroyed if any 
    */
    'quantityDestroyed': number;
    /**
    * How many of the item were dropped if any 
    */
    'quantityDropped': number;
    /**
    * singleton integer
    */
    'singleton': number;
}

/**
* Coordinates of the victim in Cartesian space relative to the Sun 
*/
export class GetKillmailsKillmailIdKillmailHashOkVictimPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* killmail_id and/or killmail_hash is not valid
*/
export class GetKillmailsKillmailIdKillmailHashUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsPrices200Ok {
    /**
    * adjusted_price number
    */
    'adjustedPrice': number;
    /**
    * average_price number
    */
    'averagePrice': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* Internal server error
*/
export class GetMarketsPricesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsRegionIdHistory200Ok {
    /**
    * average number
    */
    'average': number;
    /**
    * The date of this historical statistic entry
    */
    'date': Date;
    /**
    * highest number
    */
    'highest': number;
    /**
    * lowest number
    */
    'lowest': number;
    /**
    * Total number of orders happened that day
    */
    'orderCount': number;
    /**
    * Total
    */
    'volume': number;
}

/**
* Internal server error
*/
export class GetMarketsRegionIdHistoryInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* bad region_id
*/
export class GetMarketsRegionIdHistoryUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsRegionIdOrders200Ok {
    /**
    * duration integer
    */
    'duration': number;
    /**
    * is_buy_order boolean
    */
    'isBuyOrder': boolean;
    /**
    * issued string
    */
    'issued': Date;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * min_volume integer
    */
    'minVolume': number;
    /**
    * order_id integer
    */
    'orderId': number;
    /**
    * price number
    */
    'price': number;
    /**
    * range string
    */
    'range': GetMarketsRegionIdOrders200Ok.RangeEnum;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * volume_remain integer
    */
    'volumeRemain': number;
    /**
    * volume_total integer
    */
    'volumeTotal': number;
}

export namespace GetMarketsRegionIdOrders200Ok {
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}
/**
* Internal server error
*/
export class GetMarketsRegionIdOrdersInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* bad region_id
*/
export class GetMarketsRegionIdOrdersUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsStructuresStructureId200Ok {
    /**
    * duration integer
    */
    'duration': number;
    /**
    * is_buy_order boolean
    */
    'isBuyOrder': boolean;
    /**
    * issued string
    */
    'issued': Date;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * min_volume integer
    */
    'minVolume': number;
    /**
    * order_id integer
    */
    'orderId': number;
    /**
    * price number
    */
    'price': number;
    /**
    * range string
    */
    'range': GetMarketsStructuresStructureId200Ok.RangeEnum;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * volume_remain integer
    */
    'volumeRemain': number;
    /**
    * volume_total integer
    */
    'volumeTotal': number;
}

export namespace GetMarketsStructuresStructureId200Ok {
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}
/**
* Forbidden
*/
export class GetMarketsStructuresStructureIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetMarketsStructuresStructureIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetSearchInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetSearchOk {
    /**
    * agent array
    */
    'agent': Array<number>;
    /**
    * alliance array
    */
    'alliance': Array<number>;
    /**
    * character array
    */
    'character': Array<number>;
    /**
    * constellation array
    */
    'constellation': Array<number>;
    /**
    * corporation array
    */
    'corporation': Array<number>;
    /**
    * faction array
    */
    'faction': Array<number>;
    /**
    * inventorytype array
    */
    'inventorytype': Array<number>;
    /**
    * region array
    */
    'region': Array<number>;
    /**
    * solarsystem array
    */
    'solarsystem': Array<number>;
    /**
    * station array
    */
    'station': Array<number>;
    /**
    * wormhole array
    */
    'wormhole': Array<number>;
}

/**
* 200 ok object
*/
export class GetSovereigntyCampaigns200Ok {
    /**
    * Score for all attacking parties, only present in Defense Events. 
    */
    'attackersScore': number;
    /**
    * Unique ID for this campaign.
    */
    'campaignId': number;
    /**
    * The constellation in which the campaign will take place. 
    */
    'constellationId': number;
    /**
    * Defending alliance, only present in Defense Events 
    */
    'defenderId': number;
    /**
    * Score for the defending alliance, only present in Defense Events. 
    */
    'defenderScore': number;
    /**
    * Type of event this campaign is for. tcu_defense, ihub_defense and station_defense are referred to as \"Defense Events\", station_freeport as \"Freeport Events\". 
    */
    'eventType': GetSovereigntyCampaigns200Ok.EventTypeEnum;
    /**
    * Alliance participating and their respective scores, only present in Freeport Events. 
    */
    'participants': Array<SovereigntycampaignsParticipants>;
    /**
    * The solar system the structure is located in. 
    */
    'solarSystemId': number;
    /**
    * Time the event is scheduled to start. 
    */
    'startTime': Date;
    /**
    * The structure item ID that is related to this campaign. 
    */
    'structureId': number;
}

export namespace GetSovereigntyCampaigns200Ok {
    export enum EventTypeEnum {
        TcuDefense = <any> 'tcu_defense',
        IhubDefense = <any> 'ihub_defense',
        StationDefense = <any> 'station_defense',
        StationFreeport = <any> 'station_freeport'
    }
}
/**
* Internal server error
*/
export class GetSovereigntyCampaignsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetSovereigntyStructures200Ok {
    /**
    * The alliance that owns the structure. 
    */
    'allianceId': number;
    /**
    * Solar system in which the structure is located. 
    */
    'solarSystemId': number;
    /**
    * Unique item ID for this structure.
    */
    'structureId': number;
    /**
    * A reference to the type of structure this is. 
    */
    'structureTypeId': number;
    /**
    * The occupancy level for the next or current vulnerability window. This takes into account all development indexes and capital system bonuses. Also known as Activity Defense Multiplier from in the client. It increases the time that attackers must spend using their entosis links on the structure. 
    */
    'vulnerabilityOccupancyLevel': number;
    /**
    * The time at which the next or current vulnerability window ends. At the end of a vulnerability window the next window is recalculated and locked in along with the vulnerabilityOccupancyLevel. If the structure is not in 100% entosis control of the defender, it will go in to 'overtime' and stay vulnerable for as long as that situation persists. Only once the defenders have 100% entosis control and has the vulnerableEndTime passed does the vulnerability interval expire and a new one is calculated. 
    */
    'vulnerableEndTime': Date;
    /**
    * The next time at which the structure will become vulnerable. Or the start time of the current window if current time is between this and vulnerableEndTime. 
    */
    'vulnerableStartTime': Date;
}

/**
* Internal server error
*/
export class GetSovereigntyStructuresInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetUniverseCategoriesCategoryIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Category not found
*/
export class GetUniverseCategoriesCategoryIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseCategoriesCategoryIdOk {
    /**
    * category_id integer
    */
    'categoryId': number;
    /**
    * groups array
    */
    'groups': Array<number>;
    /**
    * name string
    */
    'name': string;
    /**
    * published boolean
    */
    'published': boolean;
}

/**
* Internal server error
*/
export class GetUniverseCategoriesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetUniverseGroupsGroupIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Group not found
*/
export class GetUniverseGroupsGroupIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseGroupsGroupIdOk {
    /**
    * category_id number
    */
    'categoryId': number;
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * types array
    */
    'types': Array<number>;
}

/**
* Internal server error
*/
export class GetUniverseGroupsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseRaces200Ok {
    /**
    * The alliance generally associated with this race
    */
    'allianceId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * name string
    */
    'name': string;
    /**
    * race_id integer
    */
    'raceId': number;
}

/**
* Internal server error
*/
export class GetUniverseRacesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetUniverseSchematicsSchematicIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Schematic not found
*/
export class GetUniverseSchematicsSchematicIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseSchematicsSchematicIdOk {
    /**
    * Time in seconds to process a run
    */
    'cycleTime': number;
    /**
    * schematic_name string
    */
    'schematicName': string;
}

/**
* Internal server error
*/
export class GetUniverseStationsStationIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseStationsStationIdOk {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * the full name of the station
    */
    'stationName': string;
}

/**
* Internal server error
*/
export class GetUniverseStructuresInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class GetUniverseStructuresStructureIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetUniverseStructuresStructureIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Not found
*/
export class GetUniverseStructuresStructureIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseStructuresStructureIdOk {
    /**
    * The full name of the structure
    */
    'name': string;
    'position': GetUniverseStructuresStructureIdOkPosition;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* Coordinates of the structure in Cartesian space relative to the Sun, in metres. 
*/
export class GetUniverseStructuresStructureIdOkPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* Internal server error
*/
export class GetUniverseSystemsSystemIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* System not found
*/
export class GetUniverseSystemsSystemIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseSystemsSystemIdOk {
    /**
    * the full name of the system
    */
    'solarSystemName': string;
}

/**
* Internal server error
*/
export class GetUniverseTypesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetUniverseTypesTypeIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Type not found
*/
export class GetUniverseTypesTypeIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseTypesTypeIdOk {
    /**
    * capacity number
    */
    'capacity': number;
    /**
    * description string
    */
    'description': string;
    /**
    * dogma_attributes array
    */
    'dogmaAttributes': Array<GetUniverseTypesTypeIdOkDogmaAttributes>;
    /**
    * dogma_effects array
    */
    'dogmaEffects': Array<GetUniverseTypesTypeIdOkDogmaEffects>;
    /**
    * graphic_id integer
    */
    'graphicId': number;
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * icon_id integer
    */
    'iconId': number;
    /**
    * mass number
    */
    'mass': number;
    /**
    * name string
    */
    'name': string;
    /**
    * portion_size integer
    */
    'portionSize': number;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * radius number
    */
    'radius': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * volume number
    */
    'volume': number;
}

/**
* dogma_attribute object
*/
export class GetUniverseTypesTypeIdOkDogmaAttributes {
    /**
    * attribute_id integer
    */
    'attributeId': number;
    /**
    * value number
    */
    'value': number;
}

/**
* dogma_effect object
*/
export class GetUniverseTypesTypeIdOkDogmaEffects {
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * is_default boolean
    */
    'isDefault': boolean;
}

/**
* Internal server error
*/
export class GetWarsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Internal server error
*/
export class GetWarsWarIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetWarsWarIdKillmails200Ok {
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
    /**
    * ID of this killmail
    */
    'killmailId': number;
}

/**
* Internal server error
*/
export class GetWarsWarIdKillmailsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* war_id is not valid
*/
export class GetWarsWarIdKillmailsUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetWarsWarIdOk {
    'aggressor': GetWarsWarIdOkAggressor;
    /**
    * allied corporations or alliances, each object contains either corporation_id or alliance_id
    */
    'allies': Array<GetWarsWarIdOkAllies>;
    /**
    * Time that the war was declared
    */
    'declared': Date;
    'defender': GetWarsWarIdOkDefender;
    /**
    * Time the war ended and shooting was no longer allowed
    */
    'finished': Date;
    /**
    * ID of the specified war
    */
    'id': number;
    /**
    * Was the war declared mutual by both parties
    */
    'mutual': boolean;
    /**
    * Is the war currently open for allies or not
    */
    'openForAllies': boolean;
    /**
    * Time the war was retracted but both sides could still shoot each other
    */
    'retracted': Date;
    /**
    * Time when the war started and both sides could shoot each other
    */
    'started': Date;
}

/**
* The aggressor corporation or alliance that declared this war, only contains either corporation_id or alliance_id
*/
export class GetWarsWarIdOkAggressor {
    /**
    * Alliance ID if and only if the aggressor is an alliance
    */
    'allianceId': number;
    /**
    * Corporation ID if and only if the aggressor is a corporation
    */
    'corporationId': number;
    /**
    * ISK value of ships the aggressor has destroyed
    */
    'iskDestroyed': number;
    /**
    * The number of ships the aggressor has killed
    */
    'shipsKilled': number;
}

/**
* ally object
*/
export class GetWarsWarIdOkAllies {
    /**
    * Alliance ID if and only if this ally is an alliance
    */
    'allianceId': number;
    /**
    * Corporation ID if and only if this ally is a corporation
    */
    'corporationId': number;
}

/**
* The defending corporation or alliance that declared this war, only contains either corporation_id or alliance_id
*/
export class GetWarsWarIdOkDefender {
    /**
    * Alliance ID if and only if the defender is an alliance
    */
    'allianceId': number;
    /**
    * Corporation ID if and only if the defender is a corporation
    */
    'corporationId': number;
    /**
    * ISK value of ships the defender has killed
    */
    'iskDestroyed': number;
    /**
    * The number of ships the defender has killed
    */
    'shipsKilled': number;
}

/**
* war_id is not valid
*/
export class GetWarsWarIdUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* cost_indice object
*/
export class IndustrysystemsCostIndices {
    /**
    * activity string
    */
    'activity': IndustrysystemsCostIndices.ActivityEnum;
    /**
    * cost_index number
    */
    'costIndex': number;
}

export namespace IndustrysystemsCostIndices {
    export enum ActivityEnum {
        None = <any> 'none',
        Manufacturing = <any> 'manufacturing',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeEfficiency = <any> 'researching_time_efficiency',
        ResearchingMaterialEfficiency = <any> 'researching_material_efficiency',
        Copying = <any> 'copying',
        Duplicating = <any> 'duplicating',
        Invention = <any> 'invention',
        ReverseEngineering = <any> 'reverse_engineering'
    }
}
/**
* level object
*/
export class InsurancepricesLevels {
    /**
    * cost number
    */
    'cost': number;
    /**
    * Localized insurance level
    */
    'name': string;
    /**
    * payout number
    */
    'payout': number;
}

/**
* Forbidden
*/
export class PostCharactersCharacterIdContactsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostCharactersCharacterIdContactsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* characters schema
*/
export class PostCharactersCharacterIdCspaCharacters {
    /**
    * characters array
    */
    'characters': Array<number>;
}

/**
* 201 created object
*/
export class PostCharactersCharacterIdCspaCreated {
    /**
    * cost integer
    */
    'cost': number;
}

/**
* Forbidden
*/
export class PostCharactersCharacterIdCspaForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostCharactersCharacterIdCspaInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 201 created object
*/
export class PostCharactersCharacterIdFittingsCreated {
    /**
    * fitting_id integer
    */
    'fittingId': number;
}

/**
* fitting object
*/
export class PostCharactersCharacterIdFittingsFitting {
    /**
    * description string
    */
    'description': string;
    /**
    * items array
    */
    'items': Array<CharacterscharacterIdfittingsItems1>;
    /**
    * name string
    */
    'name': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
}

/**
* Forbidden
*/
export class PostCharactersCharacterIdFittingsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostCharactersCharacterIdFittingsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Bad request
*/
export class PostCharactersCharacterIdMailBadRequest {
    /**
    * Bad request message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostCharactersCharacterIdMailForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostCharactersCharacterIdMailInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostCharactersCharacterIdMailLabelsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostCharactersCharacterIdMailLabelsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* label object
*/
export class PostCharactersCharacterIdMailLabelsLabel {
    /**
    * Hexadecimal string representing label color, in RGB format 
    */
    'color': PostCharactersCharacterIdMailLabelsLabel.ColorEnum;
    /**
    * name string
    */
    'name': string;
}

export namespace PostCharactersCharacterIdMailLabelsLabel {
    export enum ColorEnum {
        Ffffff = <any> '#ffffff',
        Ffff01 = <any> '#ffff01',
        Ff6600 = <any> '#ff6600',
        Fe0000 = <any> '#fe0000',
        _9a0000 = <any> '#9a0000',
        _660066 = <any> '#660066',
        _0000fe = <any> '#0000fe',
        _0099ff = <any> '#0099ff',
        _01ffff = <any> '#01ffff',
        _00ff33 = <any> '#00ff33',
        _349800 = <any> '#349800',
        _006634 = <any> '#006634',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        E6e6e6 = <any> '#e6e6e6',
        Ffffcd = <any> '#ffffcd',
        _99ffff = <any> '#99ffff',
        Ccff9a = <any> '#ccff9a'
    }
}
/**
* mail schema
*/
export class PostCharactersCharacterIdMailMail {
    /**
    * approved_cost integer
    */
    'approvedCost': number;
    /**
    * body string
    */
    'body': string;
    /**
    * recipients array
    */
    'recipients': Array<CharacterscharacterIdmailRecipients1>;
    /**
    * subject string
    */
    'subject': string;
}

/**
* Forbidden
*/
export class PostFleetsFleetIdMembersForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostFleetsFleetIdMembersInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* invitation object
*/
export class PostFleetsFleetIdMembersInvitation {
    /**
    * The character you want to invite
    */
    'characterId': number;
    /**
    * - If a character is invited with the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified - If a character is invited with the `wing_commander` role, only `wing_id` should be specified - If a character is invited with the `squad_commander` role, both `wing_id` and `squad_id` should be specified - If a character is invited with the `squad_member` role, `wing_id` and `squad_id` should either both be specified or not specified at all. If they arent specified, the invited character will join any squad with available positions 
    */
    'role': PostFleetsFleetIdMembersInvitation.RoleEnum;
    /**
    * squad_id integer
    */
    'squadId': number;
    /**
    * wing_id integer
    */
    'wingId': number;
}

export namespace PostFleetsFleetIdMembersInvitation {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* 404 not found object
*/
export class PostFleetsFleetIdMembersNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* 422 unprocessable entity object
*/
export class PostFleetsFleetIdMembersUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 201 created object
*/
export class PostFleetsFleetIdWingsCreated {
    /**
    * The wing_id of the newly created wing
    */
    'wingId': number;
}

/**
* Forbidden
*/
export class PostFleetsFleetIdWingsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostFleetsFleetIdWingsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class PostFleetsFleetIdWingsNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* 201 created object
*/
export class PostFleetsFleetIdWingsWingIdSquadsCreated {
    /**
    * The squad_id of the newly created squad
    */
    'squadId': number;
}

/**
* Forbidden
*/
export class PostFleetsFleetIdWingsWingIdSquadsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostFleetsFleetIdWingsWingIdSquadsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 404 not found object
*/
export class PostFleetsFleetIdWingsWingIdSquadsNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostUiAutopilotWaypointForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostUiAutopilotWaypointInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostUiOpenwindowContractForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostUiOpenwindowContractInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostUiOpenwindowInformationForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostUiOpenwindowInformationInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostUiOpenwindowMarketdetailsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostUiOpenwindowMarketdetailsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PostUiOpenwindowNewmailForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PostUiOpenwindowNewmailInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* new_mail object
*/
export class PostUiOpenwindowNewmailNewMail {
    /**
    * body string
    */
    'body': string;
    /**
    * recipients array
    */
    'recipients': Array<number>;
    /**
    * subject string
    */
    'subject': string;
    /**
    * to_corp_or_alliance_id integer
    */
    'toCorpOrAllianceId': number;
    /**
    * Corporations, alliances and mailing lists are all types of mailing groups. You may only send to one mailing group, at a time, so you may fill out either this field or the to_corp_or_alliance_ids field
    */
    'toMailingListId': number;
}

/**
* 422 unprocessable entity object
*/
export class PostUiOpenwindowNewmailUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class PostUniverseNames200Ok {
    /**
    * category string
    */
    'category': PostUniverseNames200Ok.CategoryEnum;
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

export namespace PostUniverseNames200Ok {
    export enum CategoryEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Constellation = <any> 'constellation',
        Corporation = <any> 'corporation',
        InventoryType = <any> 'inventory_type',
        Region = <any> 'region',
        SolarSystem = <any> 'solar_system',
        Station = <any> 'station'
    }
}
/**
* ids schema
*/
export class PostUniverseNamesIds {
    /**
    * ids array
    */
    'ids': Array<number>;
}

/**
* Internal server error
*/
export class PostUniverseNamesInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Not found
*/
export class PostUniverseNamesNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PutCharactersCharacterIdCalendarEventIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutCharactersCharacterIdCalendarEventIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* response schema
*/
export class PutCharactersCharacterIdCalendarEventIdResponse {
    /**
    * response string
    */
    'response': PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum;
}

export namespace PutCharactersCharacterIdCalendarEventIdResponse {
    export enum ResponseEnum {
        Accepted = <any> 'accepted',
        Declined = <any> 'declined',
        Tentative = <any> 'tentative'
    }
}
/**
* Forbidden
*/
export class PutCharactersCharacterIdContactsForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutCharactersCharacterIdContactsInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Bad request
*/
export class PutCharactersCharacterIdMailMailIdBadRequest {
    /**
    * Bad request message
    */
    'error': string;
}

/**
* contents object
*/
export class PutCharactersCharacterIdMailMailIdContents {
    /**
    * Labels to assign to the mail. Pre-existing labels are unassigned.
    */
    'labels': Array<number>;
    /**
    * Whether the mail is flagged as read
    */
    'read': boolean;
}

/**
* Forbidden
*/
export class PutCharactersCharacterIdMailMailIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutCharactersCharacterIdMailMailIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Bad request
*/
export class PutFleetsFleetIdBadRequest {
    /**
    * Bad request message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PutFleetsFleetIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutFleetsFleetIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PutFleetsFleetIdMembersMemberIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutFleetsFleetIdMembersMemberIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* movement object
*/
export class PutFleetsFleetIdMembersMemberIdMovement {
    /**
    * - If a character is moved to the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified - If a character is moved to the `wing_commander` role, only `wing_id` should be specified - If a character is moved to the `squad_commander` role, both `wing_id` and `squad_id` should be specified - If a character is moved to the `squad_member` role, both `wing_id` and `squad_id` should be specified 
    */
    'role': PutFleetsFleetIdMembersMemberIdMovement.RoleEnum;
    /**
    * squad_id integer
    */
    'squadId': number;
    /**
    * wing_id integer
    */
    'wingId': number;
}

export namespace PutFleetsFleetIdMembersMemberIdMovement {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* 404 not found object
*/
export class PutFleetsFleetIdMembersMemberIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* 422 unprocessable entity object
*/
export class PutFleetsFleetIdMembersMemberIdUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* new_settings object
*/
export class PutFleetsFleetIdNewSettings {
    /**
    * Should free-move be enabled in the fleet
    */
    'isFreeMove': boolean;
    /**
    * New fleet MOTD in CCP flavoured HTML
    */
    'motd': string;
}

/**
* 404 not found object
*/
export class PutFleetsFleetIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PutFleetsFleetIdSquadsSquadIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutFleetsFleetIdSquadsSquadIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* naming object
*/
export class PutFleetsFleetIdSquadsSquadIdNaming {
    /**
    * name string
    */
    'name': string;
}

/**
* 404 not found object
*/
export class PutFleetsFleetIdSquadsSquadIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* Forbidden
*/
export class PutFleetsFleetIdWingsWingIdForbidden {
    /**
    * Forbidden message
    */
    'error': string;
}

/**
* Internal server error
*/
export class PutFleetsFleetIdWingsWingIdInternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* naming object
*/
export class PutFleetsFleetIdWingsWingIdNaming {
    /**
    * name string
    */
    'name': string;
}

/**
* 404 not found object
*/
export class PutFleetsFleetIdWingsWingIdNotFound {
    /**
    * Error message
    */
    'error': string;
}

/**
* participant object
*/
export class SovereigntycampaignsParticipants {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * score number
    */
    'score': number;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum AllianceApiApiKeys {
}

export class AllianceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AllianceApiApiKeys, value: string) {
        this.authentications[AllianceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List all alliances
     * List all active player alliances  ---  Alternate route: &#x60;/v1/alliances/&#x60;  Alternate route: &#x60;/legacy/alliances/&#x60;  Alternate route: &#x60;/dev/alliances/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     */
    public getAlliances (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/alliances/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance information
     * Public information about an alliance  ---  Alternate route: &#x60;/v2/alliances/{alliance_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param allianceId An Eve alliance ID
     * @param datasource The server name you would like data from
     */
    public getAlliancesAllianceId (allianceId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdOk;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List alliance&#39;s corporations
     * List all current member corporations of an alliance  ---  Alternate route: &#x60;/v1/alliances/{alliance_id}/corporations/&#x60;  Alternate route: &#x60;/legacy/alliances/{alliance_id}/corporations/&#x60;  Alternate route: &#x60;/dev/alliances/{alliance_id}/corporations/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     */
    public getAlliancesAllianceIdCorporations (allianceId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/corporations/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdCorporations.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance icon
     * Get the icon urls for a alliance  ---  Alternate route: &#x60;/v1/alliances/{alliance_id}/icons/&#x60;  Alternate route: &#x60;/legacy/alliances/{alliance_id}/icons/&#x60;  Alternate route: &#x60;/dev/alliances/{alliance_id}/icons/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     */
    public getAlliancesAllianceIdIcons (allianceId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdIconsOk;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/icons/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdIcons.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdIconsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance names
     * Resolve a set of alliance IDs to alliance names  ---  Alternate route: &#x60;/v1/alliances/names/&#x60;  Alternate route: &#x60;/legacy/alliances/names/&#x60;  Alternate route: &#x60;/dev/alliances/names/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param allianceIds A comma separated list of alliance IDs
     * @param datasource The server name you would like data from
     */
    public getAlliancesNames (allianceIds: Array<number>, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetAlliancesNames200Ok>;  }> {
        const localVarPath = this.basePath + '/alliances/names/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceIds' is not null or undefined
        if (allianceIds === null || allianceIds === undefined) {
            throw new Error('Required parameter allianceIds was null or undefined when calling getAlliancesNames.');
        }

        if (allianceIds !== undefined) {
            queryParameters['alliance_ids'] = allianceIds.map(id => '' + id).join();
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetAlliancesNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AssetsApiApiKeys {
}

export class AssetsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AssetsApiApiKeys, value: string) {
        this.authentications[AssetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get character assets
     * Return a list of the characters assets  ---  Alternate route: &#x60;/v1/characters/{character_id}/assets/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/assets/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/assets/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId Character id of the target character
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdAssets (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAssets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAssets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAssets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BookmarksApiApiKeys {
}

export class BookmarksApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BookmarksApiApiKeys, value: string) {
        this.authentications[BookmarksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List bookmarks
     * List your character&#39;s personal bookmarks  ---  Alternate route: &#x60;/v1/characters/{character_id}/bookmarks/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/bookmarks/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/bookmarks/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdBookmarks (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarks200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/bookmarks/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarks.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarks200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List bookmark folders
     * List your character&#39;s personal bookmark folders  ---  Alternate route: &#x60;/v1/characters/{character_id}/bookmarks/folders/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/bookmarks/folders/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/bookmarks/folders/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdBookmarksFolders (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarksFolders200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/bookmarks/folders/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarksFolders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarksFolders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalendarApiApiKeys {
}

export class CalendarApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CalendarApiApiKeys, value: string) {
        this.authentications[CalendarApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List calendar event summaries
     * Get 50 event summaries from the calendar. If no event ID is given, the resource will return the next 50 chronological event summaries from now. If an event ID is specified, it will return the next 50 chronological event summaries from after that event.   ---  Alternate route: &#x60;/v1/characters/{character_id}/calendar/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/calendar/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/calendar/&#x60;   ---  This route is cached for up to 5 seconds
     * @param characterId The character to retrieve events from
     * @param fromEvent The event ID to retrieve events from
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdCalendar (characterId: number, fromEvent?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendar200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendar.');
        }

        if (fromEvent !== undefined) {
            queryParameters['from_event'] = fromEvent;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendar200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an event
     * Get all the information for a specific event  ---  Alternate route: &#x60;/v3/characters/{character_id}/calendar/{event_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/calendar/{event_id}/&#x60;   ---  This route is cached for up to 5 seconds
     * @param characterId The character id requesting the event
     * @param eventId The id of the event requested
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdCalendarEventId (characterId: number, eventId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdCalendarEventIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'event_id' + '}', String(eventId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdCalendarEventIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Respond to an event
     * Set your response status to an event  ---  Alternate route: &#x60;/v3/characters/{character_id}/calendar/{event_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/calendar/{event_id}/&#x60; 
     * @param characterId The character ID requesting the event
     * @param eventId The ID of the event requested
     * @param response The response value to set, overriding current value.
     * @param datasource The server name you would like data from
     */
    public putCharactersCharacterIdCalendarEventId (characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'event_id' + '}', String(eventId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'response' is not null or undefined
        if (response === null || response === undefined) {
            throw new Error('Required parameter response was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: response,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CharacterApiApiKeys {
}

export class CharacterApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CharacterApiApiKeys, value: string) {
        this.authentications[CharacterApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get character&#39;s public information
     * Public information about a character  ---  Alternate route: &#x60;/v3/characters/{character_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterId (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation history
     * Get a list of all the corporations a character has been a member of  ---  Alternate route: &#x60;/v1/characters/{character_id}/corporationhistory/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/corporationhistory/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/corporationhistory/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdCorporationhistory (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCorporationhistory200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/corporationhistory/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCorporationhistory.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCorporationhistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character portraits
     * Get portrait urls for a character  ---  Alternate route: &#x60;/v2/characters/{character_id}/portrait/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/portrait/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdPortrait (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPortraitOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/portrait/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPortrait.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPortraitOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character names
     * Resolve a set of character IDs to character names  ---  Alternate route: &#x60;/v1/characters/names/&#x60;  Alternate route: &#x60;/legacy/characters/names/&#x60;  Alternate route: &#x60;/dev/characters/names/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterIds A comma separated list of character IDs
     * @param datasource The server name you would like data from
     */
    public getCharactersNames (characterIds: Array<number>, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersNames200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/names/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterIds' is not null or undefined
        if (characterIds === null || characterIds === undefined) {
            throw new Error('Required parameter characterIds was null or undefined when calling getCharactersNames.');
        }

        if (characterIds !== undefined) {
            queryParameters['character_ids'] = characterIds.map(id => '' + id).join();
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate a CSPA charge cost
     * Takes a source character ID in the url and a set of target character ID&#39;s in the body, returns a CSPA charge cost  ---  Alternate route: &#x60;/v3/characters/{character_id}/cspa/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/cspa/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/cspa/&#x60; 
     * @param characterId An EVE character ID
     * @param characters The target characters to calculate the charge for
     * @param datasource The server name you would like data from
     */
    public postCharactersCharacterIdCspa (characterId: number, characters: PostCharactersCharacterIdCspaCharacters, datasource?: string) : Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdCspaCreated;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/cspa/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdCspa.');
        }

        // verify required parameter 'characters' is not null or undefined
        if (characters === null || characters === undefined) {
            throw new Error('Required parameter characters was null or undefined when calling postCharactersCharacterIdCspa.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: characters,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdCspaCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClonesApiApiKeys {
}

export class ClonesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ClonesApiApiKeys, value: string) {
        this.authentications[ClonesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get clones
     * A list of the character&#39;s clones  ---  Alternate route: &#x60;/v2/characters/{character_id}/clones/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/clones/&#x60;   ---  This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdClones (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdClonesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/clones/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdClones.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdClonesOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContactsApiApiKeys {
}

export class ContactsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContactsApiApiKeys, value: string) {
        this.authentications[ContactsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete contacts
     * Bulk delete contacts  ---  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60; 
     * @param characterId ID for a character
     * @param contactIds A list of contacts to edit
     * @param datasource The server name you would like data from
     */
    public deleteCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling deleteCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contactIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contacts
     * Return contacts of a character  ---  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60;   ---  This route is cached for up to 300 seconds
     * @param characterId ID for a character
     * @param page page integer
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdContacts (characterId: number, page?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContacts.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContacts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contact labels
     * Return custom labels for contacts the character defined  ---  Alternate route: &#x60;/v1/characters/{character_id}/contacts/labels/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/labels/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/contacts/labels/&#x60;   ---  This route is cached for up to 300 seconds
     * @param characterId ID for a character
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdContactsLabels (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContactsLabels200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/labels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContactsLabels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContactsLabels200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add contacts
     * Bulk add contacts with same settings  ---  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60; 
     * @param characterId ID for a character
     * @param standing Standing for the new contact
     * @param contactIds A list of contacts to add
     * @param watched Whether the new contact should be watched, note this is only effective on characters
     * @param labelId Add a custom label to the new contact
     * @param datasource The server name you would like data from
     */
    public postCharactersCharacterIdContacts (characterId: number, standing: number, contactIds: Array<number>, watched?: boolean, labelId?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        // verify required parameter 'standing' is not null or undefined
        if (standing === null || standing === undefined) {
            throw new Error('Required parameter standing was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        if (standing !== undefined) {
            queryParameters['standing'] = standing;
        }

        if (watched !== undefined) {
            queryParameters['watched'] = watched;
        }

        if (labelId !== undefined) {
            queryParameters['label_id'] = labelId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contactIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit contacts
     * Bulk edit contacts with same settings  ---  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60; 
     * @param characterId ID for a character
     * @param standing Standing for the contact
     * @param contactIds A list of contacts to edit
     * @param watched Whether the contact should be watched, note this is only effective on characters
     * @param labelId Add a custom label to the contact, use 0 for clearing label
     * @param datasource The server name you would like data from
     */
    public putCharactersCharacterIdContacts (characterId: number, standing: number, contactIds: Array<number>, watched?: boolean, labelId?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        // verify required parameter 'standing' is not null or undefined
        if (standing === null || standing === undefined) {
            throw new Error('Required parameter standing was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        if (standing !== undefined) {
            queryParameters['standing'] = standing;
        }

        if (watched !== undefined) {
            queryParameters['watched'] = watched;
        }

        if (labelId !== undefined) {
            queryParameters['label_id'] = labelId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contactIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CorporationApiApiKeys {
}

export class CorporationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CorporationApiApiKeys, value: string) {
        this.authentications[CorporationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get corporation information
     * Public information about a corporation  ---  Alternate route: &#x60;/v2/corporations/{corporation_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param corporationId An Eve corporation ID
     * @param datasource The server name you would like data from
     */
    public getCorporationsCorporationId (corporationId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance history
     * Get a list of all the alliances a corporation has been a member of  ---  Alternate route: &#x60;/v1/corporations/{corporation_id}/alliancehistory/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/alliancehistory/&#x60;  Alternate route: &#x60;/dev/corporations/{corporation_id}/alliancehistory/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     */
    public getCorporationsCorporationIdAlliancehistory (corporationId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAlliancehistory200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/alliancehistory/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAlliancehistory.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAlliancehistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation icon
     * Get the icon urls for a corporation  ---  Alternate route: &#x60;/v1/corporations/{corporation_id}/icons/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/icons/&#x60;  Alternate route: &#x60;/dev/corporations/{corporation_id}/icons/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     */
    public getCorporationsCorporationIdIcons (corporationId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdIconsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/icons/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIcons.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdIconsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation members
     * Read the current list of members if the calling character is a member.  ---  Alternate route: &#x60;/v2/corporations/{corporation_id}/members/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/members/&#x60;  Alternate route: &#x60;/dev/corporations/{corporation_id}/members/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param corporationId A corporation ID
     * @param datasource The server name you would like data from
     */
    public getCorporationsCorporationIdMembers (corporationId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembers200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembers200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation member roles
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  ---  Alternate route: &#x60;/v1/corporations/{corporation_id}/roles/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/roles/&#x60;  Alternate route: &#x60;/dev/corporations/{corporation_id}/roles/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param corporationId A corporation ID
     * @param datasource The server name you would like data from
     */
    public getCorporationsCorporationIdRoles (corporationId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRoles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/roles/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRoles.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRoles200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation names
     * Resolve a set of corporation IDs to corporation names  ---  Alternate route: &#x60;/v1/corporations/names/&#x60;  Alternate route: &#x60;/legacy/corporations/names/&#x60;  Alternate route: &#x60;/dev/corporations/names/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param corporationIds A comma separated list of corporation IDs
     * @param datasource The server name you would like data from
     */
    public getCorporationsNames (corporationIds: Array<number>, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsNames200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/names/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationIds' is not null or undefined
        if (corporationIds === null || corporationIds === undefined) {
            throw new Error('Required parameter corporationIds was null or undefined when calling getCorporationsNames.');
        }

        if (corporationIds !== undefined) {
            queryParameters['corporation_ids'] = corporationIds.map(id => '' + id).join();
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FittingsApiApiKeys {
}

export class FittingsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FittingsApiApiKeys, value: string) {
        this.authentications[FittingsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete fitting
     * Delete a fitting from a character  ---  Alternate route: &#x60;/v1/characters/{character_id}/fittings/{fitting_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fittings/{fitting_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/fittings/{fitting_id}/&#x60; 
     * @param characterId ID for a character
     * @param fittingId ID for a fitting of this character
     * @param datasource The server name you would like data from
     */
    public deleteCharactersCharacterIdFittingsFittingId (characterId: number, fittingId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/{fitting_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'fitting_id' + '}', String(fittingId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
        }

        // verify required parameter 'fittingId' is not null or undefined
        if (fittingId === null || fittingId === undefined) {
            throw new Error('Required parameter fittingId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fittings
     * Return fittings of a character  ---  Alternate route: &#x60;/v1/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/fittings/&#x60;   ---  This route is cached for up to 300 seconds
     * @param characterId ID for a character
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdFittings (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdFittings200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFittings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdFittings200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fitting
     * Save a new fitting for a character  ---  Alternate route: &#x60;/v1/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/fittings/&#x60; 
     * @param characterId ID for a character
     * @param fitting Details about the new fitting
     * @param datasource The server name you would like data from
     */
    public postCharactersCharacterIdFittings (characterId: number, fitting?: PostCharactersCharacterIdFittingsFitting, datasource?: string) : Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdFittingsCreated;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdFittings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: fitting,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdFittingsCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FleetsApiApiKeys {
}

export class FleetsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FleetsApiApiKeys, value: string) {
        this.authentications[FleetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Kick fleet member
     * Kick a fleet member  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/members/{member_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param memberId The character ID of a member in this fleet
     * @param datasource The server name you would like data from
     */
    public deleteFleetsFleetIdMembersMemberId (fleetId: number, memberId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/{member_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'member_id' + '}', String(memberId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete fleet squad
     * Delete a fleet squad, only empty squads can be deleted  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/squads/{squad_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param squadId The squad to delete
     * @param datasource The server name you would like data from
     */
    public deleteFleetsFleetIdSquadsSquadId (fleetId: number, squadId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/squads/{squad_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'squad_id' + '}', String(squadId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'squadId' is not null or undefined
        if (squadId === null || squadId === undefined) {
            throw new Error('Required parameter squadId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete fleet wing
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/{wing_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param wingId The wing to delete
     * @param datasource The server name you would like data from
     */
    public deleteFleetsFleetIdWingsWingId (fleetId: number, wingId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'wing_id' + '}', String(wingId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fleet information
     * Return details about a fleet  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/&#x60;   ---  This route is cached for up to 5 seconds
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     */
    public getFleetsFleetId (fleetId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetFleetsFleetIdOk;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFleetsFleetIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fleet members
     * Return information about fleet members  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/members/&#x60;   ---  This route is cached for up to 5 seconds
     * @param fleetId ID for a fleet
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getFleetsFleetIdMembers (fleetId: number, language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdMembers200Ok>;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetIdMembers.');
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdMembers200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fleet wings
     * Return information about wings in a fleet  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/&#x60;   ---  This route is cached for up to 5 seconds
     * @param fleetId ID for a fleet
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getFleetsFleetIdWings (fleetId: number, language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdWings200Ok>;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetIdWings.');
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdWings200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fleet invitation
     * Invite a character into the fleet, if a character has a CSPA charge set, it is not possible to invite them to the fleet using ESI  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/members/&#x60; 
     * @param fleetId ID for a fleet
     * @param invitation Details of the invitation
     * @param datasource The server name you would like data from
     */
    public postFleetsFleetIdMembers (fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdMembers.');
        }

        // verify required parameter 'invitation' is not null or undefined
        if (invitation === null || invitation === undefined) {
            throw new Error('Required parameter invitation was null or undefined when calling postFleetsFleetIdMembers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: invitation,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fleet wing
     * Create a new wing in a fleet  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/&#x60; 
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     */
    public postFleetsFleetIdWings (fleetId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsCreated;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdWings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fleet squad
     * Create a new squad in a fleet  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/{wing_id}/squads/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/{wing_id}/squads/&#x60; 
     * @param fleetId ID for a fleet
     * @param wingId The wing_id to create squad in
     * @param datasource The server name you would like data from
     */
    public postFleetsFleetIdWingsWingIdSquads (fleetId: number, wingId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsWingIdSquadsCreated;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/squads/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'wing_id' + '}', String(wingId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsWingIdSquadsCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update fleet
     * Update settings about a fleet  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param newSettings What to update for this fleet
     * @param datasource The server name you would like data from
     */
    public putFleetsFleetId (fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetId.');
        }

        // verify required parameter 'newSettings' is not null or undefined
        if (newSettings === null || newSettings === undefined) {
            throw new Error('Required parameter newSettings was null or undefined when calling putFleetsFleetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newSettings,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Move fleet member
     * Move a fleet member around  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/members/{member_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param memberId The character ID of a member in this fleet
     * @param movement Details of the invitation
     * @param datasource The server name you would like data from
     */
    public putFleetsFleetIdMembersMemberId (fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/{member_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'member_id' + '}', String(memberId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'movement' is not null or undefined
        if (movement === null || movement === undefined) {
            throw new Error('Required parameter movement was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: movement,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Rename fleet squad
     * Rename a fleet squad  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/squads/{squad_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param squadId The squad to rename
     * @param naming New name of the squad
     * @param datasource The server name you would like data from
     */
    public putFleetsFleetIdSquadsSquadId (fleetId: number, squadId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/squads/{squad_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'squad_id' + '}', String(squadId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'squadId' is not null or undefined
        if (squadId === null || squadId === undefined) {
            throw new Error('Required parameter squadId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'naming' is not null or undefined
        if (naming === null || naming === undefined) {
            throw new Error('Required parameter naming was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: naming,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Rename fleet wing
     * Rename a fleet wing  ---  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/{wing_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param wingId The wing to rename
     * @param naming New name of the wing
     * @param datasource The server name you would like data from
     */
    public putFleetsFleetIdWingsWingId (fleetId: number, wingId: number, naming: PutFleetsFleetIdWingsWingIdNaming, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'wing_id' + '}', String(wingId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'naming' is not null or undefined
        if (naming === null || naming === undefined) {
            throw new Error('Required parameter naming was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: naming,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IncursionsApiApiKeys {
}

export class IncursionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: IncursionsApiApiKeys, value: string) {
        this.authentications[IncursionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List incursions
     * Return a list of current incursions  ---  Alternate route: &#x60;/v1/incursions/&#x60;  Alternate route: &#x60;/legacy/incursions/&#x60;  Alternate route: &#x60;/dev/incursions/&#x60;   ---  This route is cached for up to 300 seconds
     * @param datasource The server name you would like data from
     */
    public getIncursions (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetIncursions200Ok>;  }> {
        const localVarPath = this.basePath + '/incursions/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIncursions200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IndustryApiApiKeys {
}

export class IndustryApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: IndustryApiApiKeys, value: string) {
        this.authentications[IndustryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List industry facilities
     * Return a list of industry facilities  ---  Alternate route: &#x60;/v1/industry/facilities/&#x60;  Alternate route: &#x60;/legacy/industry/facilities/&#x60;  Alternate route: &#x60;/dev/industry/facilities/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     */
    public getIndustryFacilities (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetIndustryFacilities200Ok>;  }> {
        const localVarPath = this.basePath + '/industry/facilities/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIndustryFacilities200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List solar system cost indices
     * Return cost indices for solar systems  ---  Alternate route: &#x60;/v1/industry/systems/&#x60;  Alternate route: &#x60;/legacy/industry/systems/&#x60;  Alternate route: &#x60;/dev/industry/systems/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     */
    public getIndustrySystems (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetIndustrySystems200Ok>;  }> {
        const localVarPath = this.basePath + '/industry/systems/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIndustrySystems200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InsuranceApiApiKeys {
}

export class InsuranceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InsuranceApiApiKeys, value: string) {
        this.authentications[InsuranceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List insurance levels
     * Return available insurance levels for all ship types  ---  Alternate route: &#x60;/v1/insurance/prices/&#x60;  Alternate route: &#x60;/legacy/insurance/prices/&#x60;  Alternate route: &#x60;/dev/insurance/prices/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getInsurancePrices (language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetInsurancePrices200Ok>;  }> {
        const localVarPath = this.basePath + '/insurance/prices/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetInsurancePrices200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KillmailsApiApiKeys {
}

export class KillmailsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: KillmailsApiApiKeys, value: string) {
        this.authentications[KillmailsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List kills and losses
     * Return a list of character&#39;s recent kills and losses  ---  Alternate route: &#x60;/v1/characters/{character_id}/killmails/recent/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/killmails/recent/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/killmails/recent/&#x60;   ---  This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param maxCount How many killmails to return at maximum
     * @param maxKillId Only return killmails with ID smaller than this. 
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdKillmailsRecent (characterId: number, maxCount?: number, maxKillId?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdKillmailsRecent200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/killmails/recent/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdKillmailsRecent.');
        }

        if (maxCount !== undefined) {
            queryParameters['max_count'] = maxCount;
        }

        if (maxKillId !== undefined) {
            queryParameters['max_kill_id'] = maxKillId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdKillmailsRecent200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single killmail
     * Return a single killmail from its ID and hash  ---  Alternate route: &#x60;/v1/killmails/{killmail_id}/{killmail_hash}/&#x60;  Alternate route: &#x60;/legacy/killmails/{killmail_id}/{killmail_hash}/&#x60;  Alternate route: &#x60;/dev/killmails/{killmail_id}/{killmail_hash}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param killmailId The killmail ID to be queried
     * @param killmailHash The killmail hash for verification
     * @param datasource The server name you would like data from
     */
    public getKillmailsKillmailIdKillmailHash (killmailId: number, killmailHash: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetKillmailsKillmailIdKillmailHashOk;  }> {
        const localVarPath = this.basePath + '/killmails/{killmail_id}/{killmail_hash}/'
            .replace('{' + 'killmail_id' + '}', String(killmailId))
            .replace('{' + 'killmail_hash' + '}', String(killmailHash));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'killmailId' is not null or undefined
        if (killmailId === null || killmailId === undefined) {
            throw new Error('Required parameter killmailId was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
        }

        // verify required parameter 'killmailHash' is not null or undefined
        if (killmailHash === null || killmailHash === undefined) {
            throw new Error('Required parameter killmailHash was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetKillmailsKillmailIdKillmailHashOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationApiApiKeys {
}

export class LocationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LocationApiApiKeys, value: string) {
        this.authentications[LocationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get character location
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable.  ---  Alternate route: &#x60;/v1/characters/{character_id}/location/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/location/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/location/&#x60;   ---  This route is cached for up to 5 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdLocation (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdLocationOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/location/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdLocation.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdLocationOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get current ship
     * Get the current ship type, name and id  ---  Alternate route: &#x60;/v1/characters/{character_id}/ship/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/ship/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/ship/&#x60;   ---  This route is cached for up to 5 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdShip (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdShipOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/ship/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdShip.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdShipOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MailApiApiKeys {
}

export class MailApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MailApiApiKeys, value: string) {
        this.authentications[MailApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a mail label
     * Delete a mail label  ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/labels/{label_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/labels/{label_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/labels/{label_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param labelId An EVE label id
     * @param datasource The server name you would like data from
     */
    public deleteCharactersCharacterIdMailLabelsLabelId (characterId: number, labelId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/{label_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'label_id' + '}', String(labelId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
        }

        // verify required parameter 'labelId' is not null or undefined
        if (labelId === null || labelId === undefined) {
            throw new Error('Required parameter labelId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a mail
     * Delete a mail  ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/{mail_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     */
    public deleteCharactersCharacterIdMailMailId (characterId: number, mailId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'mail_id' + '}', String(mailId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return mail headers
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards.  ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/&#x60;   ---  This route is cached for up to 30 seconds
     * @param characterId An EVE character ID
     * @param labels Fetch only mails that match one or more of the given labels
     * @param lastMailId List only mail with an ID lower than the given ID, if present
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdMail (characterId: number, labels?: Array<number>, lastMailId?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMail200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMail.');
        }

        if (labels !== undefined) {
            queryParameters['labels'] = labels.map(label => '' + label).join();
        }

        if (lastMailId !== undefined) {
            queryParameters['last_mail_id'] = lastMailId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMail200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get mail labels and unread counts
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  ---  Alternate route: &#x60;/v3/characters/{character_id}/mail/labels/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/labels/&#x60;   ---  This route is cached for up to 30 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdMailLabels (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailLabelsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLabels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailLabelsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return mailing list subscriptions
     * Return all mailing lists that the character is subscribed to   ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/lists/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/lists/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/lists/&#x60;   ---  This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdMailLists (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMailLists200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/lists/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLists.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMailLists200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a mail
     * Return the contents of an EVE mail  ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/{mail_id}/&#x60;   ---  This route is cached for up to 30 seconds
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdMailMailId (characterId: number, mailId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailMailIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'mail_id' + '}', String(mailId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailMailIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a new mail
     * Create and send a new mail  ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/&#x60; 
     * @param characterId The sender&#39;s character ID
     * @param mail The mail to send
     * @param datasource The server name you would like data from
     */
    public postCharactersCharacterIdMail (characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdMail.');
        }

        // verify required parameter 'mail' is not null or undefined
        if (mail === null || mail === undefined) {
            throw new Error('Required parameter mail was null or undefined when calling postCharactersCharacterIdMail.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: mail,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a mail label
     * Create a mail label  ---  Alternate route: &#x60;/v2/characters/{character_id}/mail/labels/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/labels/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/labels/&#x60; 
     * @param characterId An EVE character ID
     * @param label Label to create
     * @param datasource The server name you would like data from
     */
    public postCharactersCharacterIdMailLabels (characterId: number, label?: PostCharactersCharacterIdMailLabelsLabel, datasource?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdMailLabels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: label,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update metadata about a mail
     * Update metadata about a mail  ---  Alternate route: &#x60;/v1/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/mail/{mail_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param contents Data used to update the mail
     * @param datasource The server name you would like data from
     */
    public putCharactersCharacterIdMailMailId (characterId: number, mailId: number, contents: PutCharactersCharacterIdMailMailIdContents, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'mail_id' + '}', String(mailId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'contents' is not null or undefined
        if (contents === null || contents === undefined) {
            throw new Error('Required parameter contents was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contents,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MarketApiApiKeys {
}

export class MarketApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MarketApiApiKeys, value: string) {
        this.authentications[MarketApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List market prices
     * Return a list of prices  ---  Alternate route: &#x60;/v1/markets/prices/&#x60;  Alternate route: &#x60;/legacy/markets/prices/&#x60;  Alternate route: &#x60;/dev/markets/prices/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     */
    public getMarketsPrices (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsPrices200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/prices/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsPrices200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List historical market statistics in a region
     * Return a list of historical market statistics for the specified type in a region  ---  Alternate route: &#x60;/v1/markets/{region_id}/history/&#x60;  Alternate route: &#x60;/legacy/markets/{region_id}/history/&#x60;  Alternate route: &#x60;/dev/markets/{region_id}/history/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param regionId Return statistics in this region
     * @param typeId Return statistics for this type
     * @param datasource The server name you would like data from
     */
    public getMarketsRegionIdHistory (regionId: number, typeId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/history/'
            .replace('{' + 'region_id' + '}', String(regionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdHistory.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getMarketsRegionIdHistory.');
        }

        if (typeId !== undefined) {
            queryParameters['type_id'] = typeId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdHistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List orders in a region
     * Return a list of orders in a region  ---  Alternate route: &#x60;/v1/markets/{region_id}/orders/&#x60;  Alternate route: &#x60;/legacy/markets/{region_id}/orders/&#x60;  Alternate route: &#x60;/dev/markets/{region_id}/orders/&#x60;   ---  This route is cached for up to 300 seconds
     * @param regionId Return orders in this region
     * @param orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders. 
     * @param typeId Return orders only for this type
     * @param page Which page to query, only used for querying without type_id. Starting at 1 
     * @param datasource The server name you would like data from
     */
    public getMarketsRegionIdOrders (regionId: number, orderType: string, typeId?: number, page?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/orders/'
            .replace('{' + 'region_id' + '}', String(regionId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdOrders.');
        }

        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
            throw new Error('Required parameter orderType was null or undefined when calling getMarketsRegionIdOrders.');
        }

        if (typeId !== undefined) {
            queryParameters['type_id'] = typeId;
        }

        if (orderType !== undefined) {
            queryParameters['order_type'] = orderType;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdOrders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List orders in a structure
     * Return all orders in a structure  ---  Alternate route: &#x60;/v1/markets/structures/{structure_id}/&#x60;  Alternate route: &#x60;/legacy/markets/structures/{structure_id}/&#x60;  Alternate route: &#x60;/dev/markets/structures/{structure_id}/&#x60;   ---  This route is cached for up to 300 seconds
     * @param structureId Return orders in this region
     * @param page Which page to query, only used for querying without type_id. Starting at 1 
     * @param datasource The server name you would like data from
     */
    public getMarketsStructuresStructureId (structureId: number, page?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsStructuresStructureId200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/structures/{structure_id}/'
            .replace('{' + 'structure_id' + '}', String(structureId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getMarketsStructuresStructureId.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsStructuresStructureId200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlanetaryInteractionApiApiKeys {
}

export class PlanetaryInteractionApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PlanetaryInteractionApiApiKeys, value: string) {
        this.authentications[PlanetaryInteractionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get colonies
     * Returns a list of all planetary colonies owned by a character.  ---  Alternate route: &#x60;/v1/characters/{character_id}/planets/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/planets/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/planets/&#x60;   ---  This route is cached for up to 600 seconds
     * @param characterId Character id of the target character
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdPlanets (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdPlanets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/planets/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdPlanets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get colony layout
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information on this endpoint will not update until this criteria is met.  ---  Alternate route: &#x60;/v1/characters/{character_id}/planets/{planet_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/planets/{planet_id}/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/planets/{planet_id}/&#x60;   ---  This route is cached for up to 600 seconds
     * @param characterId Character id of the target character
     * @param planetId Planet id of the target planet
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdPlanetsPlanetId (characterId: number, planetId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPlanetsPlanetIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/planets/{planet_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'planet_id' + '}', String(planetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
        }

        // verify required parameter 'planetId' is not null or undefined
        if (planetId === null || planetId === undefined) {
            throw new Error('Required parameter planetId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPlanetsPlanetIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get schematic information
     * Get information on a planetary factory schematic  ---  Alternate route: &#x60;/v1/universe/schematics/{schematic_id}/&#x60;  Alternate route: &#x60;/legacy/universe/schematics/{schematic_id}/&#x60;  Alternate route: &#x60;/dev/universe/schematics/{schematic_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param schematicId A PI schematic ID
     * @param datasource The server name you would like data from
     */
    public getUniverseSchematicsSchematicId (schematicId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseSchematicsSchematicIdOk;  }> {
        const localVarPath = this.basePath + '/universe/schematics/{schematic_id}/'
            .replace('{' + 'schematic_id' + '}', String(schematicId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'schematicId' is not null or undefined
        if (schematicId === null || schematicId === undefined) {
            throw new Error('Required parameter schematicId was null or undefined when calling getUniverseSchematicsSchematicId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseSchematicsSchematicIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
}

export class SearchApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        this.authentications[SearchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Search on a string
     * Search for entities that match a given sub-string.  ---  Alternate route: &#x60;/v2/characters/{character_id}/search/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param search The string to search on
     * @param categories Type of entities to search for
     * @param language Search locale
     * @param strict Whether the search should be a strict match
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdSearch (characterId: number, search: string, categories: Array<string>, language?: string, strict?: boolean, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSearchOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/search/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (categories !== undefined) {
            queryParameters['categories'] = categories.join();
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (strict !== undefined) {
            queryParameters['strict'] = strict;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSearchOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search on a string
     * Search for entities that match a given sub-string.  ---  Alternate route: &#x60;/v1/search/&#x60;  Alternate route: &#x60;/legacy/search/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param search The string to search on
     * @param categories Type of entities to search for
     * @param language Search locale
     * @param strict Whether the search should be a strict match
     * @param datasource The server name you would like data from
     */
    public getSearch (search: string, categories: Array<string>, language?: string, strict?: boolean, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetSearchOk;  }> {
        const localVarPath = this.basePath + '/search/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getSearch.');
        }

        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling getSearch.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (categories !== undefined) {
            queryParameters['categories'] = categories.join();
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (strict !== undefined) {
            queryParameters['strict'] = strict;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSearchOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SkillsApiApiKeys {
}

export class SkillsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SkillsApiApiKeys, value: string) {
        this.authentications[SkillsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get character&#39;s skill queue
     * List the configured skill queue for the given character  ---  Alternate route: &#x60;/v2/characters/{character_id}/skillqueue/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/skillqueue/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/skillqueue/&#x60;   ---  This route is cached for up to 120 seconds
     * @param characterId Character id of the target character
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdSkillqueue (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdSkillqueue200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/skillqueue/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkillqueue.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdSkillqueue200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character skills
     * List all trained skills for the given character  ---  Alternate route: &#x60;/v3/characters/{character_id}/skills/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/skills/&#x60;   ---  This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdSkills (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSkillsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/skills/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkills.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSkillsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SovereigntyApiApiKeys {
}

export class SovereigntyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SovereigntyApiApiKeys, value: string) {
        this.authentications[SovereigntyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List sovereignty campaigns
     * Shows sovereignty data for campaigns.  ---  Alternate route: &#x60;/v1/sovereignty/campaigns/&#x60;  Alternate route: &#x60;/legacy/sovereignty/campaigns/&#x60;  Alternate route: &#x60;/dev/sovereignty/campaigns/&#x60;   ---  This route is cached for up to 5 seconds
     * @param datasource The server name you would like data from
     */
    public getSovereigntyCampaigns (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyCampaigns200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/campaigns/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyCampaigns200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List sovereignty structures
     * Shows sovereignty data for structures.  ---  Alternate route: &#x60;/v1/sovereignty/structures/&#x60;  Alternate route: &#x60;/legacy/sovereignty/structures/&#x60;  Alternate route: &#x60;/dev/sovereignty/structures/&#x60;   ---  This route is cached for up to 120 seconds
     * @param datasource The server name you would like data from
     */
    public getSovereigntyStructures (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyStructures200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/structures/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyStructures200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniverseApiApiKeys {
}

export class UniverseApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UniverseApiApiKeys, value: string) {
        this.authentications[UniverseApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get item categories
     * Get a list of item categories  ---  Alternate route: &#x60;/v1/universe/categories/&#x60;  Alternate route: &#x60;/legacy/universe/categories/&#x60;  Alternate route: &#x60;/dev/universe/categories/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     */
    public getUniverseCategories (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/categories/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item category information
     * Get information of an item category  ---  Alternate route: &#x60;/v1/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/legacy/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/dev/universe/categories/{category_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param categoryId An Eve item category ID
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getUniverseCategoriesCategoryId (categoryId: number, language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseCategoriesCategoryIdOk;  }> {
        const localVarPath = this.basePath + '/universe/categories/{category_id}/'
            .replace('{' + 'category_id' + '}', String(categoryId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getUniverseCategoriesCategoryId.');
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseCategoriesCategoryIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item groups
     * Get a list of item groups  ---  Alternate route: &#x60;/v1/universe/groups/&#x60;  Alternate route: &#x60;/legacy/universe/groups/&#x60;  Alternate route: &#x60;/dev/universe/groups/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param page Which page to query
     * @param datasource The server name you would like data from
     */
    public getUniverseGroups (page?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/groups/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item group information
     * Get information on an item group  ---  Alternate route: &#x60;/v1/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/legacy/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/dev/universe/groups/{group_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param groupId An Eve item group ID
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getUniverseGroupsGroupId (groupId: number, language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseGroupsGroupIdOk;  }> {
        const localVarPath = this.basePath + '/universe/groups/{group_id}/'
            .replace('{' + 'group_id' + '}', String(groupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getUniverseGroupsGroupId.');
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseGroupsGroupIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character races
     * Get a list of character races  ---  Alternate route: &#x60;/v1/universe/races/&#x60;  Alternate route: &#x60;/legacy/universe/races/&#x60;  Alternate route: &#x60;/dev/universe/races/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getUniverseRaces (language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseRaces200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/races/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseRaces200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get station information
     * Public information on stations  ---  Alternate route: &#x60;/v1/universe/stations/{station_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stations/{station_id}/&#x60;  Alternate route: &#x60;/dev/universe/stations/{station_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param stationId An Eve station ID
     * @param datasource The server name you would like data from
     */
    public getUniverseStationsStationId (stationId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseStationsStationIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stations/{station_id}/'
            .replace('{' + 'station_id' + '}', String(stationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stationId' is not null or undefined
        if (stationId === null || stationId === undefined) {
            throw new Error('Required parameter stationId was null or undefined when calling getUniverseStationsStationId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStationsStationIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all public structures
     * List all public structures  ---  Alternate route: &#x60;/v1/universe/structures/&#x60;  Alternate route: &#x60;/legacy/universe/structures/&#x60;  Alternate route: &#x60;/dev/universe/structures/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     */
    public getUniverseStructures (datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/structures/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get structure information
     * Returns information on requested structure, if you are on the ACL. Otherwise, returns \&quot;Forbidden\&quot; for all inputs.  ---  Alternate route: &#x60;/v1/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/legacy/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/dev/universe/structures/{structure_id}/&#x60; 
     * @param structureId An Eve structure ID
     * @param datasource The server name you would like data from
     */
    public getUniverseStructuresStructureId (structureId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseStructuresStructureIdOk;  }> {
        const localVarPath = this.basePath + '/universe/structures/{structure_id}/'
            .replace('{' + 'structure_id' + '}', String(structureId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getUniverseStructuresStructureId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStructuresStructureIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get solar system information
     * Information on solar systems  ---  Alternate route: &#x60;/v1/universe/systems/{system_id}/&#x60;  Alternate route: &#x60;/legacy/universe/systems/{system_id}/&#x60;  Alternate route: &#x60;/dev/universe/systems/{system_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param systemId An Eve solar system ID
     * @param datasource The server name you would like data from
     */
    public getUniverseSystemsSystemId (systemId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseSystemsSystemIdOk;  }> {
        const localVarPath = this.basePath + '/universe/systems/{system_id}/'
            .replace('{' + 'system_id' + '}', String(systemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'systemId' is not null or undefined
        if (systemId === null || systemId === undefined) {
            throw new Error('Required parameter systemId was null or undefined when calling getUniverseSystemsSystemId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseSystemsSystemIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get types
     * Get a list of type ids  ---  Alternate route: &#x60;/v1/universe/types/&#x60;  Alternate route: &#x60;/legacy/universe/types/&#x60;  Alternate route: &#x60;/dev/universe/types/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param page Which page to query
     * @param datasource The server name you would like data from
     */
    public getUniverseTypes (page?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/types/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get type information
     * Get information on a type  ---  Alternate route: &#x60;/v2/universe/types/{type_id}/&#x60;  Alternate route: &#x60;/dev/universe/types/{type_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param typeId An Eve item type ID
     * @param language Language to use in the response
     * @param datasource The server name you would like data from
     */
    public getUniverseTypesTypeId (typeId: number, language?: string, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseTypesTypeIdOk;  }> {
        const localVarPath = this.basePath + '/universe/types/{type_id}/'
            .replace('{' + 'type_id' + '}', String(typeId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getUniverseTypesTypeId.');
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseTypesTypeIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get names and categories for a set of ID&#39;s
     * Resolve a set of IDs to names and categories. Supported ID&#39;s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types.  ---  Alternate route: &#x60;/v1/universe/names/&#x60;  Alternate route: &#x60;/legacy/universe/names/&#x60; 
     * @param ids The ids to resolve
     * @param datasource The server name you would like data from
     */
    public postUniverseNames (ids: PostUniverseNamesIds, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<PostUniverseNames200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/names/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ids' is not null or undefined
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling postUniverseNames.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ids,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostUniverseNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserInterfaceApiApiKeys {
}

export class UserInterfaceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UserInterfaceApiApiKeys, value: string) {
        this.authentications[UserInterfaceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Set Autopilot Waypoint
     * Set a solar system as autopilot waypoint  ---  Alternate route: &#x60;/v2/ui/autopilot/waypoint/&#x60;  Alternate route: &#x60;/dev/ui/autopilot/waypoint/&#x60; 
     * @param destinationId The destination to travel to, can be solar system, station or structure&#39;s id
     * @param clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param datasource The server name you would like data from
     */
    public postUiAutopilotWaypoint (destinationId: number, clearOtherWaypoints: boolean, addToBeginning: boolean, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/autopilot/waypoint/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling postUiAutopilotWaypoint.');
        }

        // verify required parameter 'clearOtherWaypoints' is not null or undefined
        if (clearOtherWaypoints === null || clearOtherWaypoints === undefined) {
            throw new Error('Required parameter clearOtherWaypoints was null or undefined when calling postUiAutopilotWaypoint.');
        }

        // verify required parameter 'addToBeginning' is not null or undefined
        if (addToBeginning === null || addToBeginning === undefined) {
            throw new Error('Required parameter addToBeginning was null or undefined when calling postUiAutopilotWaypoint.');
        }

        if (destinationId !== undefined) {
            queryParameters['destination_id'] = destinationId;
        }

        if (clearOtherWaypoints !== undefined) {
            queryParameters['clear_other_waypoints'] = clearOtherWaypoints;
        }

        if (addToBeginning !== undefined) {
            queryParameters['add_to_beginning'] = addToBeginning;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open Contract Window
     * Open the contract window inside the client  ---  Alternate route: &#x60;/v1/ui/openwindow/contract/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/contract/&#x60;  Alternate route: &#x60;/dev/ui/openwindow/contract/&#x60; 
     * @param contractId The contract to open
     * @param datasource The server name you would like data from
     */
    public postUiOpenwindowContract (contractId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/contract/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling postUiOpenwindowContract.');
        }

        if (contractId !== undefined) {
            queryParameters['contract_id'] = contractId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open Information Window
     * Open the information window for a character, corporation or alliance inside the client  ---  Alternate route: &#x60;/v1/ui/openwindow/information/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/information/&#x60;  Alternate route: &#x60;/dev/ui/openwindow/information/&#x60; 
     * @param targetId The target to open
     * @param datasource The server name you would like data from
     */
    public postUiOpenwindowInformation (targetId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/information/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'targetId' is not null or undefined
        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling postUiOpenwindowInformation.');
        }

        if (targetId !== undefined) {
            queryParameters['target_id'] = targetId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open Market Details
     * Open the market details window for a specific typeID inside the client  ---  Alternate route: &#x60;/v1/ui/openwindow/marketdetails/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/marketdetails/&#x60;  Alternate route: &#x60;/dev/ui/openwindow/marketdetails/&#x60; 
     * @param typeId The item type to open in market window
     * @param datasource The server name you would like data from
     */
    public postUiOpenwindowMarketdetails (typeId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/marketdetails/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling postUiOpenwindowMarketdetails.');
        }

        if (typeId !== undefined) {
            queryParameters['type_id'] = typeId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open New Mail Window
     * Open the New Mail window, according to settings from the request if applicable  ---  Alternate route: &#x60;/v1/ui/openwindow/newmail/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/newmail/&#x60;  Alternate route: &#x60;/dev/ui/openwindow/newmail/&#x60; 
     * @param newMail The details of mail to create
     * @param datasource The server name you would like data from
     */
    public postUiOpenwindowNewmail (newMail: PostUiOpenwindowNewmailNewMail, datasource?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/newmail/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newMail' is not null or undefined
        if (newMail === null || newMail === undefined) {
            throw new Error('Required parameter newMail was null or undefined when calling postUiOpenwindowNewmail.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newMail,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WalletApiApiKeys {
}

export class WalletApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WalletApiApiKeys, value: string) {
        this.authentications[WalletApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List wallets and balances
     * List your wallets and their balances. Characters typically have only one wallet, with wallet_id 1000 being the master wallet.  ---  Alternate route: &#x60;/v1/characters/{character_id}/wallets/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/wallets/&#x60;  Alternate route: &#x60;/dev/characters/{character_id}/wallets/&#x60;   ---  This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     */
    public getCharactersCharacterIdWallets (characterId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWallets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallets/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWallets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWallets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WarsApiApiKeys {
}

export class WarsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WarsApiApiKeys, value: string) {
        this.authentications[WarsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List wars
     * Return a list of wars  ---  Alternate route: &#x60;/v1/wars/&#x60;  Alternate route: &#x60;/legacy/wars/&#x60;  Alternate route: &#x60;/dev/wars/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param maxWarId Only return wars with ID smaller than this.
     * @param datasource The server name you would like data from
     */
    public getWars (maxWarId?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/wars/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (maxWarId !== undefined) {
            queryParameters['max_war_id'] = maxWarId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get war information
     * Return details about a war  ---  Alternate route: &#x60;/v1/wars/{war_id}/&#x60;  Alternate route: &#x60;/legacy/wars/{war_id}/&#x60;  Alternate route: &#x60;/dev/wars/{war_id}/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param warId ID for a war
     * @param datasource The server name you would like data from
     */
    public getWarsWarId (warId: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: GetWarsWarIdOk;  }> {
        const localVarPath = this.basePath + '/wars/{war_id}/'
            .replace('{' + 'war_id' + '}', String(warId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'warId' is not null or undefined
        if (warId === null || warId === undefined) {
            throw new Error('Required parameter warId was null or undefined when calling getWarsWarId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetWarsWarIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List kills for a war
     * Return a list of kills related to a war  ---  Alternate route: &#x60;/v1/wars/{war_id}/killmails/&#x60;  Alternate route: &#x60;/legacy/wars/{war_id}/killmails/&#x60;  Alternate route: &#x60;/dev/wars/{war_id}/killmails/&#x60;   ---  This route is cached for up to 3600 seconds
     * @param warId A valid war ID
     * @param page Which page to query, starting at 1, 2000 killmails per page.
     * @param datasource The server name you would like data from
     */
    public getWarsWarIdKillmails (warId: number, page?: number, datasource?: string) : Promise<{ response: http.ClientResponse; body: Array<GetWarsWarIdKillmails200Ok>;  }> {
        const localVarPath = this.basePath + '/wars/{war_id}/killmails/'
            .replace('{' + 'war_id' + '}', String(warId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'warId' is not null or undefined
        if (warId === null || warId === undefined) {
            throw new Error('Required parameter warId was null or undefined when calling getWarsWarIdKillmails.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetWarsWarIdKillmails200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
